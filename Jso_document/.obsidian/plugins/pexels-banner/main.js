/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.js
var import_obsidian3 = require("obsidian");

// src/settings.js
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  apiProvider: "pexels",
  pexelsApiKey: "",
  pixabayApiKey: "",
  imageSize: "medium",
  imageOrientation: "landscape",
  numberOfImages: 10,
  defaultKeywords: "nature, abstract, landscape, technology, art, cityscape, wildlife, ocean, mountains, forest, space, architecture, food, travel, science, music, sports, fashion, business, education, health, culture, history, weather, transportation, industry, people, animals, plants, patterns",
  yPosition: 50,
  // Update these fields to be arrays
  customBannerField: ["banner"],
  customYPositionField: ["banner-y"],
  customContentStartField: ["content-start"],
  customImageDisplayField: ["banner-display"],
  customImageRepeatField: ["banner-repeat"],
  folderImages: [],
  contentStartPosition: 150,
  imageDisplay: "cover",
  imageRepeat: false,
  bannerHeight: 350,
  customBannerHeightField: ["banner-height"],
  fade: -75,
  customFadeField: ["banner-fade"],
  borderRadius: 17,
  customBorderRadiusField: ["banner-radius"],
  showPinIcon: true,
  pinnedImageFolder: "pixel-banner-images",
  showReleaseNotes: true,
  lastVersion: null
};
var FolderSuggestModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app2, onChoose) {
    super(app2);
    this.onChoose = onChoose;
  }
  getItems() {
    return this.app.vault.getAllLoadedFiles().filter((file) => file.children).map((folder) => folder.path);
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item) {
    this.onChoose(item);
  }
};
var FolderImageSetting = class extends import_obsidian.Setting {
  constructor(containerEl, plugin, folderImage, index, onDelete) {
    super(containerEl);
    this.plugin = plugin;
    this.folderImage = folderImage;
    this.index = index;
    this.onDelete = onDelete;
    this.setClass("folder-image-setting");
    this.settingEl.empty();
    const folderImageDeleteContainer = this.settingEl.createDiv("folder-image-delete-container");
    this.addDeleteButton(folderImageDeleteContainer);
    const infoEl = this.settingEl.createDiv("setting-item-info");
    infoEl.createDiv("setting-item-name");
    infoEl.createDiv("setting-item-description");
    this.addFolderInput();
    this.addImageInput();
    this.addImageDisplaySettings();
    this.addYPostionAndContentStart();
    this.addFadeAndBannerHeight();
    const controlEl = this.settingEl.createDiv("setting-item-control full-width-control");
    this.addBorderRadiusInput(controlEl);
    this.addDirectChildrenOnlyToggle();
  }
  addDeleteButton(containerEl) {
    const deleteButton = containerEl.createEl("button");
    deleteButton.style.marginLeft = "20px";
    deleteButton.style.width = "30px";
    deleteButton.style.height = "30px";
    deleteButton.style.padding = "0";
    deleteButton.style.border = "1px solid #80000030";
    deleteButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-trash-2"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`;
    deleteButton.addEventListener("click", async () => {
      this.plugin.settings.folderImages.splice(this.index, 1);
      await this.plugin.saveSettings();
      this.settingEl.remove();
      if (this.onDelete) {
        this.onDelete();
      }
    });
    deleteButton.addEventListener("mouseover", () => {
      deleteButton.style.color = "red";
    });
    deleteButton.addEventListener("mouseout", () => {
      deleteButton.style.color = "";
    });
  }
  addFolderInput() {
    const folderInputContainer = this.settingEl.createDiv("folder-input-container");
    const folderInput = new import_obsidian.Setting(folderInputContainer).setName("folder path").addText((text) => {
      text.setValue(this.folderImage.folder || "").onChange(async (value) => {
        this.folderImage.folder = value;
        await this.plugin.saveSettings();
      });
      this.folderInputEl = text.inputEl;
      this.folderInputEl.style.width = "300px";
    });
    folderInput.addButton((button) => button.setButtonText("Browse").onClick(() => {
      new FolderSuggestModal(this.plugin.app, (chosenPath) => {
        this.folderImage.folder = chosenPath;
        this.folderInputEl.value = chosenPath;
        this.plugin.saveSettings();
      }).open();
    }));
  }
  addImageInput() {
    const folderInputContainer = this.settingEl.createDiv("folder-input-container");
    const imageInput = new import_obsidian.Setting(folderInputContainer).setName("image url or keyword").addText((text) => {
      text.setValue(this.folderImage.image || "").onChange(async (value) => {
        this.folderImage.image = value;
        await this.plugin.saveSettings();
      });
      this.imageInputEl = text.inputEl;
      this.imageInputEl.style.width = "306px";
    });
  }
  addImageDisplaySettings(containerEl) {
    const displayContainer = this.settingEl.createDiv("display-and-repeat-container");
    const displaySetting = new import_obsidian.Setting(displayContainer).setName("image display").addDropdown((dropdown) => {
      dropdown.addOption("auto", "Auto").addOption("cover", "Cover").addOption("contain", "Contain").setValue(this.folderImage.imageDisplay || "cover").onChange(async (value) => {
        this.folderImage.imageDisplay = value;
        await this.plugin.saveSettings();
      });
      dropdown.selectEl.style.marginRight = "20px";
    });
    const repeatSetting = new import_obsidian.Setting(displayContainer).setName("repeat").addToggle((toggle) => {
      toggle.setValue(this.folderImage.imageRepeat || false).onChange(async (value) => {
        this.folderImage.imageRepeat = value;
        await this.plugin.saveSettings();
      });
    });
    const toggleEl = repeatSetting.controlEl.querySelector(".checkbox-container");
    if (toggleEl) toggleEl.style.justifyContent = "flex-start";
  }
  addYPostionAndContentStart() {
    const controlEl = this.settingEl.createDiv("setting-item-control full-width-control");
    this.addYPositionInput(controlEl);
    this.addContentStartInput(controlEl);
  }
  addFadeAndBannerHeight() {
    const controlEl = this.settingEl.createDiv("setting-item-control full-width-control");
    this.addFadeInput(controlEl);
    this.addBannerHeightInput(controlEl);
  }
  addYPositionInput(containerEl) {
    const label = containerEl.createEl("label", { text: "y-position", cls: "setting-item-name__label" });
    const sliderContainer = containerEl.createEl("div", { cls: "slider-container" });
    const slider = sliderContainer.createEl("input", {
      type: "range",
      cls: "slider",
      attr: {
        min: "0",
        max: "100",
        step: "1"
      }
    });
    slider.value = this.folderImage.yPosition || "50";
    slider.style.width = "100px";
    slider.style.marginLeft = "10px";
    const valueDisplay = sliderContainer.createEl("div", { cls: "slider-value" });
    valueDisplay.style.marginLeft = "10px";
    const updateValueDisplay = (value) => {
      valueDisplay.textContent = value;
    };
    updateValueDisplay(slider.value);
    slider.addEventListener("input", (event) => {
      updateValueDisplay(event.target.value);
    });
    slider.addEventListener("change", async () => {
      this.folderImage.yPosition = parseInt(slider.value);
      await this.plugin.saveSettings();
    });
    label.appendChild(sliderContainer);
    containerEl.appendChild(label);
  }
  addContentStartInput(containerEl) {
    const label = containerEl.createEl("label", { text: "content start", cls: "setting-item-name__label" });
    label.style.marginLeft = "20px";
    const contentStartInput = containerEl.createEl("input", {
      type: "number",
      attr: {
        min: "0"
      }
    });
    contentStartInput.style.width = "50px";
    contentStartInput.style.marginLeft = "10px";
    contentStartInput.value = this.folderImage.contentStartPosition || "150";
    contentStartInput.addEventListener("change", async () => {
      this.folderImage.contentStartPosition = parseInt(contentStartInput.value);
      await this.plugin.saveSettings();
    });
    label.appendChild(contentStartInput);
    containerEl.appendChild(label);
  }
  addBannerHeightInput(containerEl) {
    const label = containerEl.createEl("label", { text: "banner height", cls: "setting-item-name__label" });
    label.style.marginLeft = "20px";
    const heightInput = containerEl.createEl("input", {
      type: "number",
      attr: {
        min: "100",
        max: "2500"
      }
    });
    heightInput.style.width = "50px";
    heightInput.style.marginLeft = "10px";
    heightInput.value = this.folderImage.bannerHeight || "";
    heightInput.placeholder = String(this.plugin.settings.bannerHeight || 350);
    heightInput.addEventListener("change", async () => {
      let value = heightInput.value ? parseInt(heightInput.value) : null;
      if (value !== null) {
        value = Math.max(100, Math.min(2500, value));
        this.folderImage.bannerHeight = value;
        heightInput.value = value;
      } else {
        delete this.folderImage.bannerHeight;
        heightInput.value = "";
      }
      await this.plugin.saveSettings();
    });
    label.appendChild(heightInput);
    containerEl.appendChild(label);
  }
  addFadeInput(containerEl) {
    const label = containerEl.createEl("label", { text: "fade", cls: "setting-item-name__label" });
    const sliderContainer = containerEl.createEl("div", { cls: "slider-container" });
    const slider = sliderContainer.createEl("input", {
      type: "range",
      cls: "slider",
      attr: {
        min: "-1500",
        max: "100",
        step: "5"
      }
    });
    slider.value = this.folderImage.fade !== void 0 ? this.folderImage.fade : "-75";
    slider.style.width = "100px";
    slider.style.marginLeft = "10px";
    const valueDisplay = sliderContainer.createEl("div", { cls: "slider-value" });
    valueDisplay.style.marginLeft = "10px";
    const updateValueDisplay = (value) => {
      valueDisplay.textContent = value;
    };
    updateValueDisplay(slider.value);
    slider.addEventListener("input", (event) => {
      updateValueDisplay(event.target.value);
    });
    slider.addEventListener("change", async () => {
      this.folderImage.fade = parseInt(slider.value);
      await this.plugin.saveSettings();
    });
    label.appendChild(sliderContainer);
    containerEl.appendChild(label);
  }
  // Add this method
  addDirectChildrenOnlyToggle() {
    new import_obsidian.Setting(this.settingEl).setName("Direct Children Only").setDesc("Apply banner only to direct children of the folder").addToggle((toggle) => {
      toggle.setValue(this.folderImage.directChildrenOnly || false).onChange(async (value) => {
        this.folderImage.directChildrenOnly = value;
        await this.plugin.saveSettings();
      });
    });
  }
  // In FolderImageSetting class, add this method
  addBorderRadiusInput(containerEl) {
    var _a;
    const label = containerEl.createEl("label", { text: "border radius", cls: "setting-item-name__label" });
    const radiusInput = containerEl.createEl("input", {
      type: "number",
      attr: {
        min: "0",
        max: "50"
      }
    });
    radiusInput.style.width = "50px";
    radiusInput.style.marginLeft = "10px";
    radiusInput.value = (_a = this.folderImage.borderRadius) != null ? _a : "";
    radiusInput.placeholder = String(this.plugin.settings.borderRadius || 17);
    radiusInput.addEventListener("change", async () => {
      let value = radiusInput.value ? parseInt(radiusInput.value) : null;
      if (value !== null) {
        value = Math.max(0, Math.min(50, value));
        this.folderImage.borderRadius = value;
        radiusInput.value = String(value);
      } else {
        delete this.folderImage.borderRadius;
        radiusInput.value = "";
      }
      await this.plugin.saveSettings();
    });
    label.appendChild(radiusInput);
    containerEl.appendChild(label);
  }
};
function arrayToString(arr) {
  return Array.isArray(arr) ? arr.join(", ") : arr;
}
function stringToArray(str) {
  return str.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
}
function validateFieldNames(settings, allFields, currentField, newNames) {
  const validNamePattern = /^[a-zA-Z0-9_-]+$/;
  const invalidNames = newNames.filter((name) => !validNamePattern.test(name));
  if (invalidNames.length > 0) {
    return {
      isValid: false,
      message: `Invalid characters in field names (only letters, numbers, dashes, and underscores allowed): ${invalidNames.join(", ")}`
    };
  }
  const otherFields = allFields.filter((f) => f !== currentField);
  const otherFieldNames = otherFields.flatMap((f) => settings[f]);
  const duplicates = newNames.filter((name) => otherFieldNames.includes(name));
  if (duplicates.length > 0) {
    return {
      isValid: false,
      message: `Duplicate field names found: ${duplicates.join(", ")}`
    };
  }
  return { isValid: true };
}
var PixelBannerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("pixel-banner-settings");
    const mainContent = containerEl.createEl("div", { cls: "pixel-banner-main-content" });
    const { tabsEl, tabContentContainer } = this.createTabs(mainContent, ["API Settings", "General", "Custom Field Names", "Folder Images", "Examples"]);
    const apiTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "API Settings" } });
    this.createAPISettings(apiTab);
    const generalTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "General" } });
    this.createGeneralSettings(generalTab);
    const customFieldsTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "Custom Field Names" } });
    this.createCustomFieldsSettings(customFieldsTab);
    const foldersTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "Folder Images" } });
    this.createFolderSettings(foldersTab);
    const examplesTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "Examples" } });
    this.createExampleSettings(examplesTab);
    tabsEl.firstChild.click();
  }
  createTabs(containerEl, tabNames) {
    const tabsEl = containerEl.createEl("div", { cls: "pixel-banner-settings-tabs" });
    const tabContentContainer = containerEl.createEl("div", { cls: "pixel-banner-settings-tab-content-container" });
    tabNames.forEach((tabName) => {
      const tabEl = tabsEl.createEl("button", { cls: "pixel-banner-settings-tab", text: tabName });
      tabEl.addEventListener("click", () => {
        tabsEl.querySelectorAll(".pixel-banner-settings-tab").forEach((tab) => tab.removeClass("active"));
        tabContentContainer.querySelectorAll(".tab-content").forEach((content) => content.style.display = "none");
        tabEl.addClass("active");
        tabContentContainer.querySelector(`.tab-content[data-tab="${tabName}"]`).style.display = "flex";
      });
    });
    return { tabsEl, tabContentContainer };
  }
  createAPISettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "tab-callout" });
    calloutEl.createEl("div", { text: "Optionally select which API provider to use for fetching images. See the Examples tab for more information on referencing images by URL or local image. You can use any combination of API keyword, URL, or local image between notes." });
    new import_obsidian.Setting(containerEl).setName("API Provider").setDesc("Select the API provider for fetching images").addDropdown((dropdown) => dropdown.addOption("pexels", "Pexels").addOption("pixabay", "Pixabay").setValue(this.plugin.settings.apiProvider).onChange(async (value) => {
      this.plugin.settings.apiProvider = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian.Setting(containerEl).setName("Pexels API Key");
    containerEl.createEl("span", { text: "Enter your Pexels API key. Get your API key from ", cls: "setting-item-description" }).createEl("a", { href: "https://www.pexels.com/api/", text: "Pexels API" });
    const pexelsApiKeySetting = new import_obsidian.Setting(containerEl).setClass("full-width-control").addText((text) => {
      text.setPlaceholder("Pexels API key").setValue(this.plugin.settings.pexelsApiKey).onChange(async (value) => {
        this.plugin.settings.pexelsApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "calc(100% - 100px)";
    }).addButton((button) => button.setButtonText("Test API").onClick(async () => {
      const apiKey = this.plugin.settings.pexelsApiKey;
      if (!apiKey) {
        new Notice("Please enter an API key first");
        return;
      }
      button.setButtonText("Testing...");
      button.setDisabled(true);
      const isValid = await testPexelsApi(apiKey);
      button.setButtonText("Test API");
      button.setDisabled(false);
      new Notice(isValid ? "\u2705 Pexels API key is valid!" : "\u274C Invalid Pexels API key");
    }));
    pexelsApiKeySetting.settingEl.style.width = "100%";
    new import_obsidian.Setting(containerEl).setName("Pixabay API Key");
    containerEl.createEl("span", { text: "Enter your Pixabay API key. Get your API key from ", cls: "setting-item-description" }).createEl("a", { href: "https://pixabay.com/api/docs/", text: "Pixabay API" });
    const pixabayApiKeySetting = new import_obsidian.Setting(containerEl).setClass("full-width-control").addText((text) => {
      text.setPlaceholder("Pixabay API key").setValue(this.plugin.settings.pixabayApiKey).onChange(async (value) => {
        this.plugin.settings.pixabayApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "calc(100% - 100px)";
    }).addButton((button) => button.setButtonText("Test API").onClick(async () => {
      const apiKey = this.plugin.settings.pixabayApiKey;
      if (!apiKey) {
        new Notice("Please enter an API key first");
        return;
      }
      button.setButtonText("Testing...");
      button.setDisabled(true);
      const isValid = await testPixabayApi(apiKey);
      button.setButtonText("Test API");
      button.setDisabled(false);
      new Notice(isValid ? "\u2705 Pixabay API key is valid!" : "\u274C Invalid Pixabay API key");
    }));
    pixabayApiKeySetting.settingEl.style.width = "100%";
    new import_obsidian.Setting(containerEl).setName("Images").setDesc("Configure settings for images fetched from API. These settings apply when using keywords to fetch random images.").setHeading();
    new import_obsidian.Setting(containerEl).setName("Show Pin Icon").setDesc("Show a pin icon on random banner images that allows saving them to your vault. Once pinned, your frontmatter will be updated to use the local image instead of the API image.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showPinIcon).onChange(async (value) => {
      this.plugin.settings.showPinIcon = value;
      folderInputSetting.settingEl.style.display = value ? "flex" : "none";
      await this.plugin.saveSettings();
    }));
    const folderInputSetting = new import_obsidian.Setting(containerEl).setName("Pinned Images Folder").setDesc("Folder where pinned banner images will be saved").addText((text) => {
      text.setPlaceholder("pixel-banner-images").setValue(this.plugin.settings.pinnedImageFolder).onChange(async (value) => {
        this.plugin.settings.pinnedImageFolder = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.addEventListener("blur", async () => {
        let value = text.inputEl.value.trim();
        if (!value) {
          value = "pixel-banner-images";
        }
        text.setValue(value);
        this.plugin.settings.pinnedImageFolder = value;
        await this.plugin.saveSettings();
      });
      return text;
    }).addButton((button) => button.setButtonText("Clean Orphaned Pins").setTooltip("Remove pinned images that are not used in any note").onClick(async () => {
      button.setButtonText("\u{1FAE7} Cleaning...");
      button.setDisabled(true);
      try {
        const result = await this.plugin.cleanOrphanedPins();
        new Notice(`\u{1F9FC} Cleaned ${result.cleaned} orphaned pinned images`);
      } catch (error) {
        console.error("Error cleaning orphaned pins:", error);
        new Notice("Failed to clean orphaned pins");
      } finally {
        button.setButtonText("Clean Orphaned Pins");
        button.setDisabled(false);
      }
    }));
    folderInputSetting.settingEl.style.display = this.plugin.settings.showPinIcon ? "flex" : "none";
    new import_obsidian.Setting(containerEl).setName("Size").setDesc("Select the size of the image - (API only)").addDropdown((dropdown) => dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(this.plugin.settings.imageSize).onChange(async (value) => {
      this.plugin.settings.imageSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Orientation").setDesc("Select the orientation of the image - (API only)").addDropdown((dropdown) => dropdown.addOption("landscape", "Landscape").addOption("portrait", "Portrait").addOption("square", "Square").setValue(this.plugin.settings.imageOrientation).onChange(async (value) => {
      this.plugin.settings.imageOrientation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Number of images").setDesc("Enter the number of random images to fetch (3-50) - (API only)").addText((text) => text.setPlaceholder("10").setValue(String(this.plugin.settings.numberOfImages || 10)).onChange(async (value) => {
      let numValue = Number(value);
      if (!isNaN(numValue)) {
        numValue = Math.max(3, Math.min(numValue, 50));
        this.plugin.settings.numberOfImages = numValue;
        await this.plugin.saveSettings();
      }
    })).then((setting) => {
      const inputEl = setting.controlEl.querySelector("input");
      inputEl.type = "number";
      inputEl.min = "3";
      inputEl.max = "50";
      inputEl.style.width = "50px";
    });
    const defaultKeywordsSetting = new import_obsidian.Setting(containerEl).setName("Default keywords").setDesc("Enter a comma-separated list of default keywords to be used when no keyword is provided in the frontmatter, or when the provided keyword does not return any results. - (API only)").addTextArea((text) => {
      text.setPlaceholder("Enter keywords, separated by commas").setValue(this.plugin.settings.defaultKeywords).onChange(async (value) => {
        this.plugin.settings.defaultKeywords = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "100%";
      text.inputEl.style.marginTop = "15px";
      text.inputEl.style.height = "90px";
    }).addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings.defaultKeywords = DEFAULT_SETTINGS.defaultKeywords;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    defaultKeywordsSetting.settingEl.dataset.id = "defaultKeywords";
    defaultKeywordsSetting.settingEl.style.display = "flex";
    defaultKeywordsSetting.settingEl.style.flexDirection = "column";
  }
  createGeneralSettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "tab-callout" });
    calloutEl.createEl("div", { text: "Set the default vertical position of the image, how it should be displayed, and where the content should start. These are global settings and apply to all notes with banners unless overridden by folder or note-specific settings." });
    new import_obsidian.Setting(containerEl).setName("Image Vertical Position").setDesc("Set the vertical position of the image (0-100)").addSlider(
      (slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.settings.yPosition).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.yPosition = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      })
    ).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.yPosition = DEFAULT_SETTINGS.yPosition;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const sliderEl = button.extraSettingsEl.parentElement.querySelector(".slider");
      sliderEl.value = DEFAULT_SETTINGS.yPosition;
      sliderEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Content Start Position").setDesc("Set the default vertical position where the content starts (in pixels)").addText((text) => text.setPlaceholder("150").setValue(String(this.plugin.settings.contentStartPosition)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue >= 0) {
        this.plugin.settings.contentStartPosition = numValue;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      }
    })).then((setting) => {
      const inputEl = setting.controlEl.querySelector("input");
      inputEl.type = "number";
      inputEl.min = "0";
      inputEl.style.width = "60px";
    }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.contentStartPosition = DEFAULT_SETTINGS.contentStartPosition;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const inputEl = button.extraSettingsEl.parentElement.querySelector("input");
      inputEl.value = DEFAULT_SETTINGS.contentStartPosition;
      inputEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Image Display").setDesc("Set how the banner image should be displayed").addDropdown((dropdown) => dropdown.addOption("auto", "Auto").addOption("cover", "Cover").addOption("contain", "Contain").setValue(this.plugin.settings.imageDisplay || "cover").onChange(async (value) => {
      this.plugin.settings.imageDisplay = value;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.imageDisplay = DEFAULT_SETTINGS.imageDisplay;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const dropdownEl = button.extraSettingsEl.parentElement.querySelector("select");
      dropdownEl.value = DEFAULT_SETTINGS.imageDisplay;
      dropdownEl.dispatchEvent(new Event("change"));
    }));
    new import_obsidian.Setting(containerEl).setName("Image Repeat").setDesc('Enable image repetition when "Contain" is selected').addToggle((toggle) => toggle.setValue(this.plugin.settings.imageRepeat).onChange(async (value) => {
      this.plugin.settings.imageRepeat = value;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.imageRepeat = DEFAULT_SETTINGS.imageRepeat;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const checkboxContainer = button.extraSettingsEl.parentElement.querySelector(".checkbox-container");
      const toggleEl = checkboxContainer.querySelector("input");
      if (toggleEl) {
        toggleEl.checked = DEFAULT_SETTINGS.imageRepeat;
        checkboxContainer.classList.toggle("is-enabled", DEFAULT_SETTINGS.imageRepeat);
        const event = new Event("change", { bubbles: true });
        toggleEl.dispatchEvent(event);
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Banner Height").setDesc("Set the default height of the banner image (100-2500 pixels)").addText((text) => {
      text.setPlaceholder("350").setValue(String(this.plugin.settings.bannerHeight)).onChange(async (value) => {
        if (value === "" || !isNaN(Number(value))) {
          await this.plugin.saveSettings();
        }
      });
      text.inputEl.addEventListener("blur", async (event) => {
        let numValue = Number(event.target.value);
        if (isNaN(numValue) || event.target.value === "") {
          numValue = 350;
        } else {
          numValue = Math.max(100, Math.min(2500, numValue));
        }
        this.plugin.settings.bannerHeight = numValue;
        text.setValue(String(numValue));
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      });
      text.inputEl.type = "number";
      text.inputEl.min = "100";
      text.inputEl.max = "2500";
      text.inputEl.style.width = "50px";
    }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.bannerHeight = DEFAULT_SETTINGS.bannerHeight;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const inputEl = button.extraSettingsEl.parentElement.querySelector("input");
      inputEl.value = DEFAULT_SETTINGS.bannerHeight;
      inputEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Banner Fade").setDesc("Set the default fade effect for the banner image (-1500 to 100)").addSlider(
      (slider) => slider.setLimits(-1500, 100, 5).setValue(this.plugin.settings.fade).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.fade = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      })
    ).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.fade = DEFAULT_SETTINGS.fade;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const sliderEl = button.extraSettingsEl.parentElement.querySelector(".slider");
      sliderEl.value = DEFAULT_SETTINGS.fade;
      sliderEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Border Radius").setDesc("Set the default border radius of the banner image (0-50 pixels)").addText((text) => {
      text.setPlaceholder("17").setValue(String(this.plugin.settings.borderRadius)).onChange(async (value) => {
        const numValue = Number(value);
        if (!isNaN(numValue)) {
          this.plugin.settings.borderRadius = Math.max(0, Math.min(50, numValue));
          await this.plugin.saveSettings();
          this.plugin.updateAllBanners();
        }
      });
      text.inputEl.type = "number";
      text.inputEl.min = "0";
      text.inputEl.max = "50";
      text.inputEl.style.width = "50px";
    }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.borderRadius = DEFAULT_SETTINGS.borderRadius;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
      const inputEl = button.extraSettingsEl.parentElement.querySelector("input");
      inputEl.value = DEFAULT_SETTINGS.borderRadius;
      inputEl.dispatchEvent(new Event("input"));
    }));
    new import_obsidian.Setting(containerEl).setName("Show Release Notes").setDesc("Show release notes after plugin updates").addToggle((toggle) => toggle.setValue(this.plugin.settings.showReleaseNotes).onChange(async (value) => {
      this.plugin.settings.showReleaseNotes = value;
      await this.plugin.saveSettings();
    })).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      this.plugin.settings.showReleaseNotes = DEFAULT_SETTINGS.showReleaseNotes;
      await this.plugin.saveSettings();
      const toggleEl = button.extraSettingsEl.parentElement.querySelector(".checkbox-container input");
      if (toggleEl) {
        toggleEl.checked = DEFAULT_SETTINGS.showReleaseNotes;
        toggleEl.dispatchEvent(new Event("change"));
      }
    }));
  }
  createCustomFieldsSettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "tab-callout" });
    calloutEl.createEl("div", { text: 'Customize the frontmatter field names used for the banner and Y-position. You can define multiple names for each field, separated by commas. Field names can only contain letters, numbers, dashes, and underscores. Example: "banner, pixel-banner, header_image" could all be used as the banner field name.' });
    const customFields = [
      {
        setting: "customBannerField",
        name: "Banner Field Names",
        desc: "Set custom field names for the banner in frontmatter (comma-separated)",
        placeholder: "banner, pixel-banner, header-image"
      },
      {
        setting: "customYPositionField",
        name: "Y-Position Field Names",
        desc: "Set custom field names for the Y-position in frontmatter (comma-separated)",
        placeholder: "banner-y, y-position, banner-offset"
      },
      {
        setting: "customContentStartField",
        name: "Content Start Position Field Names",
        desc: "Set custom field names for the content start position in frontmatter (comma-separated)",
        placeholder: "content-start, start-position, content-offset"
      },
      {
        setting: "customImageDisplayField",
        name: "Image Display Field Names",
        desc: "Set custom field names for the image display in frontmatter (comma-separated)",
        placeholder: "banner-display, image-display, display-mode"
      },
      {
        setting: "customImageRepeatField",
        name: "Image Repeat Field Names",
        desc: "Set custom field names for the image repeat in frontmatter (comma-separated)",
        placeholder: "banner-repeat, image-repeat, repeat-image"
      },
      {
        setting: "customBannerHeightField",
        name: "Banner Height Field Names",
        desc: "Set custom field names for the banner height in frontmatter (comma-separated)",
        placeholder: "banner-height, image-height, header-height"
      },
      {
        setting: "customFadeField",
        name: "Fade Field Names",
        desc: "Set custom field names for the fade effect in frontmatter (comma-separated)",
        placeholder: "banner-fade, fade-effect, image-fade"
      },
      {
        setting: "customBorderRadiusField",
        name: "Border Radius Field Names",
        desc: "Set custom field names for the border radius in frontmatter (comma-separated)",
        placeholder: "banner-radius, border-radius, banner-corner-radius"
      }
    ];
    customFields.forEach((field) => {
      new import_obsidian.Setting(containerEl).setName(field.name).setDesc(field.desc).addText((text) => {
        text.setPlaceholder(field.placeholder).setValue(arrayToString(this.plugin.settings[field.setting])).onChange(async (value) => {
          const newNames = stringToArray(value);
          const validation = validateFieldNames(
            this.plugin.settings,
            customFields.map((f) => f.setting),
            field.setting,
            newNames
          );
          if (validation.isValid) {
            this.plugin.settings[field.setting] = newNames;
            await this.plugin.saveSettings();
          } else {
            new Notice(validation.message);
            text.setValue(arrayToString(this.plugin.settings[field.setting]));
          }
        });
        text.inputEl.style.width = "220px";
      }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings[field.setting] = DEFAULT_SETTINGS[field.setting];
        await this.plugin.saveSettings();
        const settingEl = button.extraSettingsEl.parentElement;
        const textInput = settingEl.querySelector('input[type="text"]');
        textInput.value = arrayToString(DEFAULT_SETTINGS[field.setting]);
        const event = new Event("input", { bubbles: true, cancelable: true });
        textInput.dispatchEvent(event);
      }));
    });
  }
  createFolderSettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "tab-callout" });
    calloutEl.createEl("div", { text: 'Set default banner images for specific folders. These will apply to all notes in the folder unless overridden by note-specific settings. To get started, add a folder image setting and click the "+ Add Folder Image Setting" button below.' });
    const folderImagesContainer = containerEl.createDiv("folder-images-container");
    const updateFolderSettings = () => {
      var _a, _b;
      folderImagesContainer.empty();
      const sortedFolderImages = [...this.plugin.settings.folderImages].sort((a, b) => {
        const folderA = (a.folder || "").toLowerCase();
        const folderB = (b.folder || "").toLowerCase();
        return folderA.localeCompare(folderB);
      });
      this.plugin.settings.folderImages = sortedFolderImages;
      const folderSettings = sortedFolderImages.map(
        (folderImage, index) => new FolderImageSetting(folderImagesContainer, this.plugin, folderImage, index, updateFolderSettings)
      );
      if (this.shouldFocusNewFolder) {
        (_b = (_a = folderSettings[0]) == null ? void 0 : _a.folderInputEl) == null ? void 0 : _b.focus();
        this.shouldFocusNewFolder = false;
      }
    };
    updateFolderSettings();
    const addFolderContainer = containerEl.createDiv("add-folder-image-setting");
    new import_obsidian.Setting(addFolderContainer).addButton((button) => button.setButtonText("+ Add Folder Image Setting").onClick(async () => {
      this.plugin.settings.folderImages.push({ folder: "", image: "", yPosition: 50, contentStartPosition: 150 });
      await this.plugin.saveSettings();
      this.shouldFocusNewFolder = true;
      updateFolderSettings();
    }));
  }
  createExampleSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("How to use").setHeading();
    const getRandomFieldName = (fieldNames) => {
      const names = Array.isArray(fieldNames) ? fieldNames : [fieldNames];
      return names[Math.floor(Math.random() * names.length)];
    };
    const instructionsEl = containerEl.createEl("div", { cls: "pixel-banner-section" });
    instructionsEl.createEl("p", { text: "Add the following fields to your note's frontmatter to customize the banner:" });
    const codeEl = instructionsEl.createEl("pre");
    codeEl.createEl("code", {
      text: `---
${getRandomFieldName(this.plugin.settings.customBannerField)}: blue turtle
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 30
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 200
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: contain
${getRandomFieldName(this.plugin.settings.customImageRepeatField)}: true
${getRandomFieldName(this.plugin.settings.customBannerHeightField)}: 400
${getRandomFieldName(this.plugin.settings.customFadeField)}: -75
${getRandomFieldName(this.plugin.settings.customBorderRadiusField)}: 25
---

# Or use a direct URL:
---
${getRandomFieldName(this.plugin.settings.customBannerField)}: https://example.com/image.jpg
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 70
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 180
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: cover
${getRandomFieldName(this.plugin.settings.customBannerHeightField)}: 300
${getRandomFieldName(this.plugin.settings.customFadeField)}: -75
${getRandomFieldName(this.plugin.settings.customBorderRadiusField)}: 0
---

# Or use a path to an image in the vault:
---
${getRandomFieldName(this.plugin.settings.customBannerField)}: Assets/my-image.png
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 0
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 100
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: auto
${getRandomFieldName(this.plugin.settings.customBannerHeightField)}: 250
${getRandomFieldName(this.plugin.settings.customFadeField)}: -75
${getRandomFieldName(this.plugin.settings.customBorderRadiusField)}: 50
---

# Or use an Obsidian internal link:
---
${getRandomFieldName(this.plugin.settings.customBannerField)}: [[example-image.png]]
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 100
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 50
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: contain
${getRandomFieldName(this.plugin.settings.customImageRepeatField)}: false
${getRandomFieldName(this.plugin.settings.customBannerHeightField)}: 500
${getRandomFieldName(this.plugin.settings.customFadeField)}: -75
${getRandomFieldName(this.plugin.settings.customBorderRadiusField)}: 17
---`
    });
    instructionsEl.createEl("p", { text: 'Note: The image display options are "auto", "cover", or "contain". The image repeat option is only applicable when the display is set to "contain".' });
    containerEl.createEl("img", {
      attr: {
        src: "https://raw.githubusercontent.com/jparkerweb/pixel-banner/main/example.jpg",
        alt: "Example of a Pixel banner",
        style: "max-width: 100%; height: auto; margin-top: 10px; border-radius: 5px;"
      }
    });
  }
  validateFieldName(value, otherFieldName) {
    if (value === otherFieldName) {
      new Notice("Field names must be unique!");
      return false;
    }
    return true;
  }
};
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
async function testPexelsApi(apiKey) {
  try {
    const response = await fetch("https://api.pexels.com/v1/search?query=test&per_page=3", {
      headers: {
        "Authorization": apiKey
      }
    });
    if (!response.ok) {
      throw new Error("\u274C Invalid Pexels API key");
    }
    const data = await response.json();
    return data.photos && data.photos.length > 0;
  } catch (error) {
    return false;
  }
}
async function testPixabayApi(apiKey) {
  try {
    const response = await fetch(`https://pixabay.com/api/?key=${apiKey}&q=test&per_page=3`);
    const data = await response.json();
    if (data.error) {
      throw new Error(data.error);
    }
    return true;
  } catch (error) {
    return false;
  }
}

// src/modals.js
var import_obsidian2 = require("obsidian");
var ReleaseNotesModal = class extends import_obsidian2.Modal {
  constructor(app2, version, releaseNotes2) {
    super(app2);
    this.version = version;
    this.releaseNotes = releaseNotes2;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: `Welcome to \u{1F6A9} Pixel Banner v${this.version}` });
    contentEl.createEl("p", {
      text: "After each update you'll be prompted with the release notes. You can disable this in the plugin settings General tab."
    });
    const kofiContainer = contentEl.createEl("div");
    kofiContainer.style.textAlign = "right";
    const kofiLink = kofiContainer.createEl("a", {
      href: "https://ko-fi.com/Z8Z212UMBI",
      target: "_blank"
    });
    kofiLink.createEl("img", {
      attr: {
        height: "36",
        style: "border:0px;height:36px;",
        src: "https://raw.githubusercontent.com/jparkerweb/pixel-banner/refs/heads/main/img/support.png",
        border: "0",
        alt: "Buy Me a Coffee at ko-fi.com"
      }
    });
    const notesContainer = contentEl.createDiv("release-notes-container");
    notesContainer.innerHTML = this.releaseNotes;
    contentEl.createEl("div", { cls: "release-notes-spacer" }).style.height = "20px";
    new import_obsidian2.Setting(contentEl).addButton((btn) => btn.setButtonText("Close").onClick(() => this.close()));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// virtual-module:virtual:release-notes
var releaseNotes = "<h2>\u{1F389} What&#39;s New</h2>\n<h3>v2.5.6 - v2.5.1</h3>\n<h4>Added</h4>\n<ul>\n<li>Note frontmatter now updated to allow for keywords separated by commas when using API (allowing for more random variety per note)</li>\n<li><code>Folder Images</code> keywords input now supports multiple keywords separated by commas (allowing for more random variety per folder)</li>\n<li>When &quot;Pinning&quot; an image, the plugin now waits for potential a rename/move of the file to the local vault before updating the note frontmatter</li>\n</ul>\n<h4>Fixed</h4>\n<ul>\n<li>&quot;Pinnings&quot; now correctly updates note frontmatter to use local image when saving if the note didn&#39;t already have a banner field</li>\n<li>Fix issue where a defined &quot;Folder Images&quot; path of root <code>/</code> was not being respected</li>\n<li>Description messages in settings page is now rendering properly acoss all tabs</li>\n<li>Scroll the pin icon with note content</li>\n</ul>\n<hr>\n<h3>v2.5.0</h3>\n<h4>Added</h4>\n<ul>\n<li>Pin Icon Feature: Save API images to your vault<ul>\n<li>Click the pin icon (\u{1F4CC}) to save random banner images locally</li>\n<li>Choose custom filenames when saving</li>\n<li>Automatically updates note frontmatter to use local image</li>\n<li>Configure save location in settings</li>\n</ul>\n</li>\n<li>Orphaned Pins Cleanup: Utility to remove unused pinned images<ul>\n<li>Clean up button in settings</li>\n<li>Safely moves unused images to trash</li>\n<li>Checks all custom banner field names</li>\n</ul>\n</li>\n</ul>\n";

// src/main.js
module.exports = class PixelBannerPlugin extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "debounceTimer", null);
    __publicField(this, "loadedImages", /* @__PURE__ */ new Map());
    __publicField(this, "lastKeywords", /* @__PURE__ */ new Map());
    __publicField(this, "imageCache", /* @__PURE__ */ new Map());
    __publicField(this, "rateLimiter", {
      lastRequestTime: 0,
      minInterval: 1e3
      // 1 second between requests
    });
    __publicField(this, "lastYPositions", /* @__PURE__ */ new Map());
    __publicField(this, "lastFrontmatter", /* @__PURE__ */ new Map());
    __publicField(this, "pendingImageUpdates", /* @__PURE__ */ new Map());
    __publicField(this, "debouncedEnsureBanner", debounce(() => {
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf && activeLeaf.view instanceof import_obsidian3.MarkdownView) {
        this.updateBanner(activeLeaf.view, false);
      }
    }, 100));
  }
  // Track files waiting for potential renames
  async onload() {
    await this.loadSettings();
    await this.checkVersion();
    this.addSettingTab(new PixelBannerSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange.bind(this))
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", this.handleMetadataChange.bind(this))
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", this.handleLayoutChange.bind(this))
    );
    this.registerEvent(
      this.app.workspace.on("mode-change", this.handleModeChange.bind(this))
    );
    this.registerMarkdownPostProcessor(this.postProcessor.bind(this));
    this.setupMutationObserver();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.migrateCustomFields();
    if (!Array.isArray(this.settings.folderImages)) {
      this.settings.folderImages = [];
    }
    if (this.settings.folderImages) {
      this.settings.folderImages.forEach((folderImage) => {
        folderImage.imageDisplay = folderImage.imageDisplay || "cover";
        folderImage.imageRepeat = folderImage.imageRepeat || false;
        folderImage.directChildrenOnly = folderImage.directChildrenOnly || false;
      });
    }
  }
  migrateCustomFields() {
    const fieldsToMigrate = [
      "customBannerField",
      "customYPositionField",
      "customContentStartField",
      "customImageDisplayField",
      "customImageRepeatField"
    ];
    fieldsToMigrate.forEach((field) => {
      if (typeof this.settings[field] === "string") {
        console.log(`converting ${field} to array`);
        this.settings[field] = [this.settings[field]];
      } else if (!Array.isArray(this.settings[field])) {
        console.log(`setting default value for ${field}`);
        this.settings[field] = DEFAULT_SETTINGS[field];
      }
    });
    this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.loadedImages.clear();
    this.lastKeywords.clear();
    this.imageCache.clear();
    const activeLeaf = this.app.workspace.activeLeaf;
    if (activeLeaf && activeLeaf.view.getViewType() === "markdown") {
      await this.updateBanner(activeLeaf.view, true);
    }
  }
  async handleActiveLeafChange(leaf) {
    if (leaf && leaf.view instanceof import_obsidian3.MarkdownView && leaf.view.file) {
      await this.updateBanner(leaf.view, false);
    }
  }
  async handleMetadataChange(file) {
    var _a;
    const activeLeaf = this.app.workspace.activeLeaf;
    if (activeLeaf && activeLeaf.view instanceof import_obsidian3.MarkdownView && activeLeaf.view.file && activeLeaf.view.file === file) {
      const currentFrontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      const cachedFrontmatter = this.lastFrontmatter.get(file.path);
      if (this.isFrontmatterChange(cachedFrontmatter, currentFrontmatter)) {
        this.lastFrontmatter.set(file.path, currentFrontmatter);
        await this.updateBanner(activeLeaf.view, true);
      }
    }
  }
  isFrontmatterChange(cachedFrontmatter, currentFrontmatter) {
    if (!cachedFrontmatter && !currentFrontmatter) return false;
    if (!cachedFrontmatter || !currentFrontmatter) return true;
    return JSON.stringify(cachedFrontmatter) !== JSON.stringify(currentFrontmatter);
  }
  handleLayoutChange() {
    setTimeout(() => {
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf && (activeLeaf.view instanceof import_obsidian3.MarkdownView || activeLeaf.view.getViewType() === "markdown")) {
        this.updateBanner(activeLeaf.view, false);
      }
    }, 100);
  }
  async handleModeChange(leaf) {
    if (leaf && leaf.view instanceof import_obsidian3.MarkdownView && leaf.view.file) {
      await this.updateBanner(leaf.view, true);
    }
  }
  async updateBanner(view, isContentChange) {
    var _a;
    if (!view || !view.file) {
      return;
    }
    const frontmatter = (_a = this.app.metadataCache.getFileCache(view.file)) == null ? void 0 : _a.frontmatter;
    const contentEl = view.contentEl;
    let yPosition = this.settings.yPosition;
    let contentStartPosition = this.settings.contentStartPosition;
    let bannerImage = getFrontmatterValue(frontmatter, this.settings.customBannerField);
    if (bannerImage && typeof bannerImage === "string" && !bannerImage.startsWith("[[")) {
      const bannerValues = bannerImage.includes(",") ? bannerImage.split(",").map((v) => v.trim()).filter((v) => v.length > 0).filter(Boolean) : [bannerImage];
      if (bannerValues.length > 0) {
        bannerImage = bannerValues[Math.floor(Math.random() * bannerValues.length)];
      } else {
        bannerImage = null;
      }
    }
    if (Array.isArray(bannerImage)) {
      bannerImage = bannerImage.flat()[0];
      bannerImage = `[[${bannerImage}]]`;
    }
    const folderSpecific = this.getFolderSpecificImage(view.file.path);
    if (folderSpecific) {
      bannerImage = bannerImage || folderSpecific.image;
      yPosition = folderSpecific.yPosition;
      contentStartPosition = folderSpecific.contentStartPosition;
    }
    if (frontmatter) {
      const customYPosition = getFrontmatterValue(frontmatter, this.settings.customYPositionField);
      if (customYPosition !== void 0) {
        yPosition = customYPosition;
      }
      const customContentStart = getFrontmatterValue(frontmatter, this.settings.customContentStartField);
      if (customContentStart !== void 0) {
        contentStartPosition = customContentStart;
      }
    }
    if (isContentChange) {
      this.loadedImages.delete(view.file.path);
      this.lastKeywords.delete(view.file.path);
    }
    await this.addPixelBanner(contentEl, {
      frontmatter,
      file: view.file,
      isContentChange,
      yPosition,
      contentStartPosition,
      customBannerField: this.settings.customBannerField,
      customYPositionField: this.settings.customYPositionField,
      customContentStartField: this.settings.customContentStartField,
      bannerImage,
      isReadingView: view.getMode && view.getMode() === "preview"
    });
    this.lastYPositions.set(view.file.path, yPosition);
    const embeddedNotes = contentEl.querySelectorAll(".internal-embed");
    for (const embed of embeddedNotes) {
      const embedFile = this.app.metadataCache.getFirstLinkpathDest(embed.getAttribute("src"), "");
      if (embedFile) {
        const embedView = {
          file: embedFile,
          contentEl: embed,
          getMode: () => "preview"
        };
        await this.updateBanner(embedView, false);
      }
    }
  }
  async addPixelBanner(el, ctx) {
    var _a, _b, _c, _d, _e, _f;
    const { frontmatter, file, isContentChange, yPosition, contentStartPosition, bannerImage, isReadingView } = ctx;
    const viewContent = el;
    const isEmbedded = viewContent.classList.contains("internal-embed");
    if (!isEmbedded && !viewContent.classList.contains("view-content")) {
      return;
    }
    viewContent.classList.toggle("pixel-banner", !!bannerImage);
    let container;
    if (isEmbedded) {
      container = viewContent.querySelector(".markdown-embed-content");
    } else {
      container = isReadingView ? viewContent.querySelector(".markdown-preview-sizer:not(.internal-embed .markdown-preview-sizer)") : viewContent.querySelector(".cm-sizer");
    }
    if (!container) {
      return;
    }
    let bannerDiv = container.querySelector(":scope > .pixel-banner-image");
    let pinIcon = container.querySelector(":scope > .pin-icon");
    if (!bannerDiv) {
      bannerDiv = createDiv({ cls: "pixel-banner-image" });
      container.insertBefore(bannerDiv, container.firstChild);
      bannerDiv._isPersistentBanner = true;
      if (this.settings.showPinIcon) {
        pinIcon = createDiv({ cls: "pin-icon" });
        pinIcon.style.position = "absolute";
        pinIcon.style.top = "10px";
        pinIcon.style.left = "5px";
        pinIcon.style.fontSize = "1.5em";
        pinIcon.style.cursor = "pointer";
        pinIcon.innerHTML = "\u{1F4CC}";
        pinIcon._isPersistentPin = true;
        container.insertBefore(pinIcon, bannerDiv.nextSibling);
      }
      if (!container._hasOverriddenSetChildrenInPlace) {
        const originalSetChildrenInPlace = container.setChildrenInPlace;
        container.setChildrenInPlace = function(children) {
          const bannerElement = this.querySelector(":scope > .pixel-banner-image");
          const pinElement = this.querySelector(":scope > .pin-icon");
          children = Array.from(children);
          if (bannerElement == null ? void 0 : bannerElement._isPersistentBanner) {
            children = [bannerElement, ...children];
          }
          if (pinElement == null ? void 0 : pinElement._isPersistentPin) {
            children.splice(1, 0, pinElement);
          }
          originalSetChildrenInPlace.call(this, children);
        };
        container._hasOverriddenSetChildrenInPlace = true;
      }
    }
    if (bannerImage) {
      let imageUrl = this.loadedImages.get(file.path);
      const lastInput = this.lastKeywords.get(file.path);
      const inputType = this.getInputType(bannerImage);
      if (!imageUrl || isContentChange && bannerImage !== lastInput) {
        imageUrl = await this.getImageUrl(inputType, bannerImage);
        if (imageUrl) {
          this.loadedImages.set(file.path, imageUrl);
          this.lastKeywords.set(file.path, bannerImage);
        }
      }
      if (imageUrl) {
        bannerDiv.style.backgroundImage = `url('${imageUrl}')`;
        bannerDiv.style.backgroundPosition = `center ${yPosition}%`;
        bannerDiv.style.backgroundSize = getFrontmatterValue(frontmatter, this.settings.customImageDisplayField) || this.getFolderSpecificSetting(file.path, "imageDisplay") || this.settings.imageDisplay || "cover";
        const shouldRepeat = getFrontmatterValue(frontmatter, this.settings.customImageRepeatField);
        if (shouldRepeat !== void 0) {
          const repeatValue = String(shouldRepeat).toLowerCase() === "true";
          bannerDiv.style.backgroundRepeat = repeatValue ? "repeat" : "no-repeat";
        } else {
          bannerDiv.style.backgroundRepeat = bannerDiv.style.backgroundSize === "contain" && (this.getFolderSpecificSetting(file.path, "imageRepeat") || this.settings.imageRepeat) ? "repeat" : "no-repeat";
        }
        const bannerHeight = getFrontmatterValue(frontmatter, this.settings.customBannerHeightField) || this.getFolderSpecificSetting(file.path, "bannerHeight") || this.settings.bannerHeight || 350;
        bannerDiv.style.setProperty("--pixel-banner-height", `${bannerHeight}px`);
        const fadeValue = (_c = (_b = (_a = getFrontmatterValue(frontmatter, this.settings.customFadeField)) != null ? _a : this.getFolderSpecificSetting(file.path, "fade")) != null ? _b : this.settings.fade) != null ? _c : -75;
        bannerDiv.style.setProperty("--pixel-banner-fade", `${fadeValue}%`);
        const borderRadius = (_f = (_e = (_d = getFrontmatterValue(frontmatter, this.settings.customBorderRadiusField)) != null ? _d : this.getFolderSpecificSetting(file.path, "borderRadius")) != null ? _e : this.settings.borderRadius) != null ? _f : 17;
        bannerDiv.style.setProperty("--pixel-banner-radius", `${borderRadius}px`);
        bannerDiv.style.display = "block";
        if (inputType === "keyword" && this.settings.showPinIcon && pinIcon) {
          pinIcon.style.display = "block";
          pinIcon.onclick = async () => {
            try {
              await handlePinIconClick(imageUrl, this);
            } catch (error) {
              console.error("Error pinning image:", error);
              new import_obsidian3.Notice("\u{1F62D} Failed to pin the image.");
            }
          };
        } else if (pinIcon) {
          pinIcon.style.display = "none";
        }
      }
    } else {
      bannerDiv.style.display = "none";
      if (pinIcon) {
        pinIcon.style.display = "none";
      }
      this.loadedImages.delete(file.path);
      this.lastKeywords.delete(file.path);
      this.applyContentStartPosition(viewContent, 0);
    }
    this.applyContentStartPosition(viewContent, contentStartPosition);
  }
  setupMutationObserver() {
    this.observer = new MutationObserver((mutations) => {
      for (let mutation of mutations) {
        if (mutation.type === "childList") {
          const removedNodes = Array.from(mutation.removedNodes);
          const addedNodes = Array.from(mutation.addedNodes);
          const bannerRemoved = removedNodes.some(
            (node) => node.classList && node.classList.contains("pixel-banner-image")
          );
          const contentChanged = addedNodes.some(
            (node) => node.nodeType === Node.ELEMENT_NODE && (node.classList.contains("markdown-preview-section") || node.classList.contains("cm-content"))
          );
          if (bannerRemoved || contentChanged) {
            this.debouncedEnsureBanner();
          }
        }
      }
    });
    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  getFolderSpecificImage(filePath) {
    const folderPath = this.getFolderPath(filePath);
    for (const folderImage of this.settings.folderImages) {
      let folderBannerImage = folderImage.image;
      if (folderBannerImage && typeof folderBannerImage === "string" && !folderBannerImage.startsWith("[[")) {
        const bannerValues = folderBannerImage.includes(",") ? folderBannerImage.split(",").map((v) => v.trim()).filter((v) => v.length > 0).filter(Boolean) : [folderBannerImage];
        if (bannerValues.length > 0) {
          folderBannerImage = bannerValues[Math.floor(Math.random() * bannerValues.length)];
        } else {
          folderBannerImage = null;
        }
      }
      if (folderImage.folder === "/") {
        if (folderImage.directChildrenOnly) {
          if (!filePath.includes("/")) {
            return {
              image: folderBannerImage,
              yPosition: folderImage.yPosition,
              contentStartPosition: folderImage.contentStartPosition
            };
          }
        } else {
          return {
            image: folderBannerImage,
            yPosition: folderImage.yPosition,
            contentStartPosition: folderImage.contentStartPosition
          };
        }
        continue;
      }
      if (folderImage.directChildrenOnly) {
        if (folderPath === folderImage.folder) {
          return {
            image: folderBannerImage,
            yPosition: folderImage.yPosition,
            contentStartPosition: folderImage.contentStartPosition
          };
        }
      } else if (folderPath.startsWith(folderImage.folder)) {
        return {
          image: folderBannerImage,
          yPosition: folderImage.yPosition,
          contentStartPosition: folderImage.contentStartPosition
        };
      }
    }
    return null;
  }
  getFolderPath(filePath) {
    if (!filePath.includes("/")) {
      return "/";
    }
    const lastSlashIndex = filePath.lastIndexOf("/");
    return lastSlashIndex !== -1 ? filePath.substring(0, lastSlashIndex) : "";
  }
  async getImageUrl(type, input) {
    if (type === "url" || type === "path") {
      return input;
    }
    if (type === "obsidianLink") {
      const file = this.getPathFromObsidianLink(input);
      if (file) {
        return this.getVaultImageUrl(file.path);
      }
      return null;
    }
    if (type === "vaultPath") {
      return this.getVaultImageUrl(input);
    }
    if (type === "keyword") {
      const keywords = input.includes(",") ? input.split(",").map((k) => k.trim()).filter((k) => k.length > 0).filter(Boolean) : [input];
      if (keywords.length > 0) {
        const selectedKeyword = keywords[Math.floor(Math.random() * keywords.length)];
        if (this.settings.apiProvider === "pexels") {
          return this.fetchPexelsImage(selectedKeyword);
        } else if (this.settings.apiProvider === "pixabay") {
          return this.fetchPixabayImage(selectedKeyword);
        }
      }
      return null;
    }
    return null;
  }
  async fetchPexelsImage(keyword) {
    const apiKey = this.settings.pexelsApiKey;
    if (!apiKey) {
      new import_obsidian3.Notice("Pexels API key is not set. Please set it in the plugin settings.");
      return null;
    }
    const now = Date.now();
    if (now - this.rateLimiter.lastRequestTime < this.rateLimiter.minInterval) {
      await new Promise((resolve) => setTimeout(resolve, this.rateLimiter.minInterval));
    }
    this.rateLimiter.lastRequestTime = Date.now();
    const defaultKeywords = this.settings.defaultKeywords.split(",").map((k) => k.trim());
    const fallbackKeyword = defaultKeywords[Math.floor(Math.random() * defaultKeywords.length)];
    const keywords = [keyword, fallbackKeyword];
    for (const currentKeyword of keywords) {
      try {
        const response = await (0, import_obsidian3.requestUrl)({
          url: `https://api.pexels.com/v1/search?query=${encodeURIComponent(currentKeyword)}&per_page=${this.settings.numberOfImages}&size=${this.settings.imageSize}&orientation=${this.settings.imageOrientation}`,
          method: "GET",
          headers: {
            "Authorization": apiKey
          }
        });
        if (response.status !== 200) {
          console.error("Failed to fetch images:", response.status, response.text);
          continue;
        }
        const data = response.json;
        if (data.photos && data.photos.length > 0) {
          const randomIndex = Math.floor(Math.random() * data.photos.length);
          if (currentKeyword !== keyword) {
            console.log(`No image found for "${keyword}". Using image for "${currentKeyword}" instead.`);
          }
          const imageUrl = data.photos[randomIndex].src[this.settings.imageSize];
          try {
            await this.preloadImage(imageUrl);
          } catch (error) {
            console.error(`Failed to preload image: ${error.message}`);
          }
          return imageUrl;
        } else if (currentKeyword === keyword) {
          console.log(`No image found for the provided keyword: "${keyword}". Trying a random default keyword.`);
        }
      } catch (error) {
        console.error(`Error fetching image from API for keyword "${currentKeyword}":`, error);
        new import_obsidian3.Notice(`Failed to fetch image: ${error.message}`);
      }
    }
    console.error("No images found for any keywords, including the random default.");
    return null;
  }
  async fetchPixabayImage(keyword) {
    const apiKey = this.settings.pixabayApiKey;
    if (!apiKey) {
      new import_obsidian3.Notice("Pixabay API key is not set. Please set it in the plugin settings.");
      return null;
    }
    const defaultKeywords = this.settings.defaultKeywords.split(",").map((k) => k.trim());
    const keywordsToTry = [keyword, ...defaultKeywords];
    const maxAttempts = 4;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const currentKeyword = attempt === 0 ? keyword : keywordsToTry[Math.floor(Math.random() * keywordsToTry.length)];
      const apiUrl = "https://pixabay.com/api/";
      const params = new URLSearchParams({
        key: apiKey,
        q: encodeURIComponent(currentKeyword),
        image_type: "photo",
        per_page: this.settings.numberOfImages,
        safesearch: true
      });
      try {
        const response = await this.makeRequest(`${apiUrl}?${params}`);
        if (response.status !== 200) {
          console.error(`Pixabay API error: ${response.status} ${response.statusText}`);
          continue;
        }
        let data;
        if (response.arrayBuffer) {
          const text = new TextDecoder().decode(response.arrayBuffer);
          try {
            data = JSON.parse(text);
          } catch (error) {
            console.error("Failed to parse Pixabay response:", error);
            continue;
          }
        } else {
          console.error("Unexpected response format:", response);
          continue;
        }
        if (data.hits && data.hits.length > 0) {
          const imageUrls = data.hits.map((hit) => hit.largeImageURL);
          if (imageUrls.length > 0) {
            const randomIndex = Math.floor(Math.random() * imageUrls.length);
            const selectedImageUrl = imageUrls[randomIndex];
            return selectedImageUrl;
          }
        }
        console.log(`No images found for keyword: ${currentKeyword}`);
      } catch (error) {
        console.error("Error fetching image from Pixabay:", error);
      }
    }
    console.error("No images found after all attempts");
    new import_obsidian3.Notice("Failed to fetch an image after multiple attempts, try a different keyword and/or update the backup keyword list in settings.");
    return null;
  }
  async makeRequest(url) {
    const now = Date.now();
    if (now - this.rateLimiter.lastRequestTime < this.rateLimiter.minInterval) {
      await new Promise((resolve) => setTimeout(resolve, this.rateLimiter.minInterval));
    }
    this.rateLimiter.lastRequestTime = Date.now();
    try {
      const response = await (0, import_obsidian3.requestUrl)({ url });
      return response;
    } catch (error) {
      console.error("Request failed:", error);
      throw new Error(`Request failed: ${error.message}`);
    }
  }
  preloadImage(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(url);
      img.onerror = reject;
      img.src = url;
    });
  }
  getInputType(input) {
    if (Array.isArray(input)) {
      input = input.flat()[0];
    }
    if (typeof input !== "string") {
      return "invalid";
    }
    input = input.trim().replace(/^["'](.*)["']$/, "$1");
    if (input.startsWith("[[") && input.endsWith("]]")) {
      return "obsidianLink";
    }
    try {
      new URL(input);
      return "url";
    } catch (_) {
      const file = this.app.vault.getAbstractFileByPath(input);
      if (file && "extension" in file) {
        if (file.extension.match(/^(jpg|jpeg|png|gif|bmp|svg)$/i)) {
          return "vaultPath";
        }
      }
      return "keyword";
    }
  }
  getPathFromObsidianLink(link) {
    let innerLink = link.startsWith("[[") ? link.slice(2) : link;
    innerLink = innerLink.endsWith("]]") ? innerLink.slice(0, -2) : innerLink;
    const path = innerLink.split("|")[0];
    return this.app.metadataCache.getFirstLinkpathDest(path, "");
  }
  async getVaultImageUrl(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && "extension" in file) {
      try {
        const arrayBuffer = await this.app.vault.readBinary(file);
        const blob = new Blob([arrayBuffer], { type: `image/${file.extension}` });
        return URL.createObjectURL(blob);
      } catch (error) {
        console.error("Error reading vault image:", error);
        return null;
      }
    }
    return null;
  }
  updateAllBanners() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() === "markdown") {
        this.updateBanner(leaf.view, true);
      }
    });
  }
  async postProcessor(el, ctx) {
    const frontmatter = ctx.frontmatter;
    if (frontmatter && frontmatter[this.settings.customBannerField]) {
      await this.addPixelBanner(el, {
        frontmatter,
        file: ctx.sourcePath,
        isContentChange: false,
        yPosition: frontmatter[this.settings.customYPositionField] || this.settings.yPosition,
        contentStartPosition: frontmatter[this.settings.customContentStartField] || this.settings.contentStartPosition,
        customBannerField: this.settings.customBannerField,
        customYPositionField: this.settings.customYPositionField,
        customContentStartField: this.settings.customContentStartField,
        customImageDisplayField: this.settings.customImageDisplayField,
        customImageRepeatField: this.settings.customImageRepeatField,
        bannerImage: frontmatter[this.settings.customBannerField]
      });
    }
  }
  onunload() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
  applyContentStartPosition(el, contentStartPosition) {
    el.style.setProperty("--pixel-banner-content-start", `${contentStartPosition}px`);
  }
  getFolderSpecificSetting(filePath, settingName) {
    var _a;
    const folderPath = this.getFolderPath(filePath);
    for (const folderImage of this.settings.folderImages) {
      if (folderPath.startsWith(folderImage.folder)) {
        return (_a = folderImage[settingName]) != null ? _a : void 0;
      }
    }
    return void 0;
  }
  async cleanOrphanedPins() {
    var _a;
    const vault = this.app.vault;
    const folderPath = this.settings.pinnedImageFolder;
    let cleaned = 0;
    try {
      if (!await vault.adapter.exists(folderPath)) {
        return { cleaned };
      }
      const pinnedFolder = vault.getAbstractFileByPath(folderPath);
      if (!pinnedFolder || !pinnedFolder.children) {
        return { cleaned };
      }
      const imageExtensions = ["png", "jpg", "jpeg", "gif", "bmp", "webp", "svg"];
      const pinnedImages = pinnedFolder.children.filter((file) => imageExtensions.includes(file.extension.toLowerCase())).map((file) => file.path);
      if (!pinnedImages.length) {
        return { cleaned };
      }
      const markdownFiles = this.app.vault.getMarkdownFiles();
      const bannerFields = this.settings.customBannerField;
      const referencedImages = /* @__PURE__ */ new Set();
      for (const file of markdownFiles) {
        const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        if (frontmatter) {
          for (const field of bannerFields) {
            const bannerValue = frontmatter[field];
            if (bannerValue && typeof bannerValue === "string") {
              const cleanPath = bannerValue.replace(/[\[\]]/g, "").trim();
              referencedImages.add(cleanPath);
            }
          }
        }
      }
      for (const imagePath of pinnedImages) {
        if (!referencedImages.has(imagePath)) {
          await vault.trash(vault.getAbstractFileByPath(imagePath), true);
          cleaned++;
        }
      }
      return { cleaned };
    } catch (error) {
      console.error("Error in cleanOrphanedPins:", error);
      throw error;
    }
  }
  async checkVersion() {
    const currentVersion = this.manifest.version;
    const lastVersion = this.settings.lastVersion;
    if (this.settings.showReleaseNotes && (!lastVersion || lastVersion !== currentVersion)) {
      const releaseNotes2 = await this.getReleaseNotes(currentVersion);
      new ReleaseNotesModal(this.app, currentVersion, releaseNotes2).open();
      this.settings.lastVersion = currentVersion;
      await this.saveSettings();
    }
  }
  async getReleaseNotes(version) {
    return releaseNotes;
  }
};
function getFrontmatterValue(frontmatter, fieldNames) {
  if (!frontmatter || !Array.isArray(fieldNames)) return void 0;
  for (const fieldName of fieldNames) {
    if (fieldName in frontmatter) {
      const value = frontmatter[fieldName];
      if (typeof value === "string" && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        return value.toLowerCase() === "true";
      }
      return value;
    }
  }
  return void 0;
}
async function handlePinIconClick(imageUrl, plugin) {
  const imageBlob = await fetchImage(imageUrl);
  const { initialPath, file } = await saveImageLocally(imageBlob, plugin);
  const finalPath = await waitForFileRename(file, plugin);
  if (!finalPath) {
    console.error("\u274C Failed to resolve valid file path");
    new import_obsidian3.Notice("Failed to save image - file not found");
    return;
  }
  await updateNoteFrontmatter(finalPath, plugin);
  hidePinIcon();
}
async function fetchImage(url) {
  const response = await fetch(url);
  if (!response.ok) throw new Error("Image download failed");
  return await response.arrayBuffer();
}
async function saveImageLocally(arrayBuffer, plugin) {
  const vault = plugin.app.vault;
  const folderPath = plugin.settings.pinnedImageFolder;
  if (!await vault.adapter.exists(folderPath)) {
    await vault.createFolder(folderPath);
  }
  const suggestedName = "pixel-banner-image";
  const userInput = await new Promise((resolve) => {
    const modal = new SaveImageModal(plugin.app, suggestedName, (result) => {
      resolve(result);
    });
    modal.open();
  });
  if (!userInput) {
    throw new Error("No filename provided");
  }
  let baseName = userInput.replace(/[^a-zA-Z0-9-_ ]/g, "").trim();
  if (!baseName) baseName = "banner";
  if (!baseName.toLowerCase().endsWith(".png")) baseName += ".png";
  let fileName = baseName;
  let counter = 1;
  while (await vault.adapter.exists(`${folderPath}/${fileName}`)) {
    const nameWithoutExt = baseName.slice(0, -4);
    fileName = `${nameWithoutExt}-${counter}.png`;
    counter++;
  }
  const filePath = `${folderPath}/${fileName}`;
  const savedFile = await vault.createBinary(filePath, arrayBuffer);
  return {
    initialPath: filePath,
    file: savedFile
  };
}
async function updateNoteFrontmatter(imagePath, plugin) {
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile) return;
  const fileContent = await app.vault.read(activeFile);
  const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
  const hasFrontmatter = frontmatterRegex.test(fileContent);
  const bannerField = Array.isArray(plugin.settings.customBannerField) && plugin.settings.customBannerField.length > 0 ? plugin.settings.customBannerField[0] : "banner";
  let updatedContent;
  if (hasFrontmatter) {
    updatedContent = fileContent.replace(frontmatterRegex, (match, frontmatter) => {
      const bannerRegex = new RegExp(`${bannerField}:\\s*.+`);
      if (bannerRegex.test(frontmatter)) {
        return match.replace(bannerRegex, `${bannerField}: ${imagePath}`);
      } else {
        return `---
${frontmatter.trim()}
${bannerField}: ${imagePath}
---`;
      }
    });
  } else {
    updatedContent = `---
${bannerField}: ${imagePath}
---

${fileContent}`;
  }
  await app.vault.modify(activeFile, updatedContent);
}
function hidePinIcon() {
  const pinIcon = document.querySelector(".pin-icon");
  if (pinIcon) pinIcon.style.display = "none";
}
var SaveImageModal = class extends import_obsidian3.Modal {
  constructor(app2, suggestedName, onSubmit) {
    super(app2);
    this.suggestedName = suggestedName;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Save Banner Image" });
    const inputContainer = contentEl.createDiv();
    inputContainer.style.margin = "1em 0";
    const input = inputContainer.createEl("input", {
      type: "text",
      value: this.suggestedName
    });
    input.style.width = "100%";
    input.focus();
    const buttonContainer = contentEl.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "1em";
    buttonContainer.style.marginTop = "1em";
    const submitButton = buttonContainer.createEl("button", {
      text: "Save"
    });
    submitButton.addEventListener("click", () => {
      this.onSubmit(input.value);
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => {
      this.onSubmit(null);
      this.close();
    });
    input.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmit(input.value);
        this.close();
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
async function waitForFileRename(file, plugin) {
  return new Promise((resolve) => {
    const initialPath = file.path;
    let timeoutId;
    let renamedPath = null;
    const validatePath = async (path) => {
      if (!path) return false;
      return await plugin.app.vault.adapter.exists(path);
    };
    const handleRename = async (theFile) => {
      if (theFile == null ? void 0 : theFile.path) {
        renamedPath = theFile == null ? void 0 : theFile.path;
      }
    };
    const cleanup = () => {
      plugin.app.vault.off("rename", handleRename);
    };
    plugin.app.vault.on("rename", handleRename);
    timeoutId = setTimeout(async () => {
      cleanup();
      if (renamedPath) {
        const exists = await validatePath(renamedPath);
        if (exists) {
          return resolve(renamedPath);
        }
      }
      const initialExists = await validatePath(initialPath);
      if (initialExists) {
        return resolve(initialPath);
      }
      resolve(null);
    }, 1500);
  });
}

/* nosourcemap */